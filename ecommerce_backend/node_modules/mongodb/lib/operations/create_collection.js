'use strict';

const Aspect = require('./operation').Aspect;
const defineAspects = require('./operation').defineAspects;
const CommandOperation = require('./command');
const applyWriteConcern = require('../utils').applyWriteConcern;
<<<<<<< HEAD
=======
const handleCallback = require('../utils').handleCallback;
>>>>>>> 6b88e76aa9671c4029d5c0011f1eb027164f1610
const loadCollection = require('../dynamic_loaders').loadCollection;
const MongoError = require('../core').MongoError;
const ReadPreference = require('../core').ReadPreference;

<<<<<<< HEAD
const ILLEGAL_COMMAND_FIELDS = new Set([
=======
// Filter out any write concern options
const illegalCommandFields = [
>>>>>>> 6b88e76aa9671c4029d5c0011f1eb027164f1610
  'w',
  'wtimeout',
  'j',
  'fsync',
  'autoIndexId',
  'strict',
  'serializeFunctions',
  'pkFactory',
  'raw',
  'readPreference',
  'session',
  'readConcern',
  'writeConcern'
<<<<<<< HEAD
]);
=======
];
>>>>>>> 6b88e76aa9671c4029d5c0011f1eb027164f1610

class CreateCollectionOperation extends CommandOperation {
  constructor(db, name, options) {
    super(db, options);
<<<<<<< HEAD
=======

>>>>>>> 6b88e76aa9671c4029d5c0011f1eb027164f1610
    this.name = name;
  }

  _buildCommand() {
    const name = this.name;
    const options = this.options;

<<<<<<< HEAD
    const cmd = { create: name };
=======
    // Create collection command
    const cmd = { create: name };
    // Add all optional parameters
>>>>>>> 6b88e76aa9671c4029d5c0011f1eb027164f1610
    for (let n in options) {
      if (
        options[n] != null &&
        typeof options[n] !== 'function' &&
<<<<<<< HEAD
        !ILLEGAL_COMMAND_FIELDS.has(n)
=======
        illegalCommandFields.indexOf(n) === -1
>>>>>>> 6b88e76aa9671c4029d5c0011f1eb027164f1610
      ) {
        cmd[n] = options[n];
      }
    }

    return cmd;
  }

  execute(callback) {
    const db = this.db;
    const name = this.name;
    const options = this.options;
<<<<<<< HEAD
    const Collection = loadCollection();

    let listCollectionOptions = Object.assign({ nameOnly: true, strict: false }, options);
    listCollectionOptions = applyWriteConcern(listCollectionOptions, { db }, listCollectionOptions);

    function done(err) {
      if (err) {
        return callback(err);
      }

      try {
        callback(
          null,
          new Collection(db, db.s.topology, db.databaseName, name, db.s.pkFactory, options)
        );
      } catch (err) {
        callback(err);
      }
    }

    const strictMode = listCollectionOptions.strict;
    if (strictMode) {
      db.listCollections({ name }, listCollectionOptions)
        .setReadPreference(ReadPreference.PRIMARY)
        .toArray((err, collections) => {
          if (err) {
            return callback(err);
          }

          if (collections.length > 0) {
            return callback(
              new MongoError(`Collection ${name} already exists. Currently in strict mode.`)
            );
          }

          super.execute(done);
        });

      return;
    }

    // otherwise just execute the command
    super.execute(done);
=======

    let Collection = loadCollection();

    // Did the user destroy the topology
    if (db.serverConfig && db.serverConfig.isDestroyed()) {
      return callback(new MongoError('topology was destroyed'));
    }

    let listCollectionOptions = Object.assign({}, options, { nameOnly: true });
    listCollectionOptions = applyWriteConcern(listCollectionOptions, { db }, listCollectionOptions);

    // Check if we have the name
    db.listCollections({ name }, listCollectionOptions)
      .setReadPreference(ReadPreference.PRIMARY)
      .toArray((err, collections) => {
        if (err != null) return handleCallback(callback, err, null);
        if (collections.length > 0 && listCollectionOptions.strict) {
          return handleCallback(
            callback,
            MongoError.create({
              message: `Collection ${name} already exists. Currently in strict mode.`,
              driver: true
            }),
            null
          );
        } else if (collections.length > 0) {
          try {
            return handleCallback(
              callback,
              null,
              new Collection(db, db.s.topology, db.databaseName, name, db.s.pkFactory, options)
            );
          } catch (err) {
            return handleCallback(callback, err);
          }
        }

        // Execute command
        super.execute(err => {
          if (err) return handleCallback(callback, err);

          try {
            return handleCallback(
              callback,
              null,
              new Collection(db, db.s.topology, db.databaseName, name, db.s.pkFactory, options)
            );
          } catch (err) {
            return handleCallback(callback, err);
          }
        });
      });
>>>>>>> 6b88e76aa9671c4029d5c0011f1eb027164f1610
  }
}

defineAspects(CreateCollectionOperation, Aspect.WRITE_OPERATION);
<<<<<<< HEAD
=======

>>>>>>> 6b88e76aa9671c4029d5c0011f1eb027164f1610
module.exports = CreateCollectionOperation;
